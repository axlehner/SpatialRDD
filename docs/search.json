[{"path":"https://axlehner.github.io/SpatialRDD/articles/shifting_borders.html","id":"more-on-placebo-bordering","dir":"Articles","previous_headings":"","what":"More on placebo bordering","title":"Shifting Borders, Creating Polygons from Lines","text":"border approximating line space curving bending (.e. cases), “placebo bordering” can tricky straightforward. simple substraction/addition specified distance distance2cutoff variable also accurate description placebo boundary. top simple transformation distance column can best placebo check “pooled” polynomial specification border segments change thus assignment categories fixed effects. placebo GRD design iteration boundarypoints literally impossible case. proper robustness check thus create new cut-can extract corresponding borderpoints (discretise_border()) also assign border segment categories fixed effects estimations (border_segment()). shift_border() function can execute three different (affine) transformations time: \"shift\" units CRS along x- & y-axis (provided option shift = c(dist1, dist2)) \"scale\" percent around centroid, 0.9 mean 90% \"rotate\" degrees around centroid standard rotation matrix \\[ rotation = \\begin{bmatrix} \\cos \\theta & -\\sin \\theta \\\\   \\sin \\theta & \\cos \\theta \\\\ \\end{bmatrix} \\]","code":""},{"path":"https://axlehner.github.io/SpatialRDD/articles/shifting_borders.html","id":"rotate","dir":"Articles","previous_headings":"More on placebo bordering","what":"Rotate","title":"Shifting Borders, Creating Polygons from Lines","text":"","code":"tm_rotate.sf10 <- shift_border(border = cut_off.sf, operation = \"rotate\", angle = 10) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_rotate.sf25 <- shift_border(border = cut_off.sf, operation = \"rotate\", angle = 25) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_rotate.sf45 <- shift_border(border = cut_off.sf, operation = \"rotate\", angle = 45) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable!  tm_shape(polygon_full.sf) + tm_polygons() + tm_shape(cut_off.sf) + tm_lines() +    tm_shape(tm_rotate.sf10) + tm_lines(col = \"red\") +    tm_shape(tm_rotate.sf25) + tm_lines(col = \"red\") +    tm_shape(tm_rotate.sf45) + tm_lines(col = \"red\")"},{"path":"https://axlehner.github.io/SpatialRDD/articles/shifting_borders.html","id":"scale","dir":"Articles","previous_headings":"More on placebo bordering","what":"Scale","title":"Shifting Borders, Creating Polygons from Lines","text":"","code":"tm_scale.sf.4 <- shift_border(border = cut_off.sf, operation = \"scale\", scale = .4) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_scale.sf.7 <- shift_border(border = cut_off.sf, operation = \"scale\", scale = .7) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_scale.sf1.5 <- shift_border(border = cut_off.sf, operation = \"scale\", scale = 1.5) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable!  tm_shape(polygon_full.sf) + tm_polygons() + tm_shape(cut_off.sf) + tm_lines() +    tm_shape(tm_scale.sf.4) + tm_lines(col = \"blue\") +    tm_shape(tm_scale.sf.7) + tm_lines(col = \"red\") +    tm_shape(tm_scale.sf1.5) + tm_lines(col = \"red\")"},{"path":"https://axlehner.github.io/SpatialRDD/articles/shifting_borders.html","id":"shift","dir":"Articles","previous_headings":"More on placebo bordering","what":"Shift","title":"Shifting Borders, Creating Polygons from Lines","text":"last shifted line can already see movement along x-axis quite often requires also correction y-axis cut-movement meaningful. going explored detail following section together operations.","code":"tm_shift.sf3 <- shift_border(border = cut_off.sf, operation = \"shift\", shift = c(3000, 0)) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_shift.sf6 <- shift_border(border = cut_off.sf, operation = \"shift\", shift = c(6000, 0)) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_shift.sf_4 <- shift_border(border = cut_off.sf, operation = \"shift\", shift = c(-4000, 0)) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable!   tm_shape(polygon_full.sf) + tm_polygons() + tm_shape(cut_off.sf) + tm_lines() +    tm_shape(tm_shift.sf3) + tm_lines(col = \"red\") +    tm_shape(tm_shift.sf6) + tm_lines(col = \"red\") +    tm_shape(tm_shift.sf_4) + tm_lines(col = \"blue\")     tm_shift.sf_42 <- shift_border(border = cut_off.sf, operation = \"shift\", shift = c(-4000, -2000)) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_shift.sf_44 <- shift_border(border = cut_off.sf, operation = \"shift\", shift = c(-4000, -4000)) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable!  tm_shape(polygon_full.sf) + tm_polygons() + tm_shape(cut_off.sf) + tm_lines() +    tm_shape(tm_shift.sf_42) + tm_lines(col = \"red\") +    tm_shape(tm_shift.sf_44) + tm_lines(col = \"red\") +    tm_shape(tm_shift.sf_4) + tm_lines(col = \"blue\")"},{"path":"https://axlehner.github.io/SpatialRDD/articles/shifting_borders.html","id":"full-fledged-placebo-bordering","dir":"Articles","previous_headings":"More on placebo bordering","what":"Full fledged “placebo bordering”","title":"Shifting Borders, Creating Polygons from Lines","text":"proper placebo border ideally involves shift re-scaling meaningful.   according polygons assign treated dummies:","code":"tm_placebo.sf1 <- shift_border(border = cut_off.sf, operation = c(\"shift\", \"scale\"), shift = c(-5000, -3000), scale = .85) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_placebo.sf2 <- shift_border(border = cut_off.sf, operation = c(\"shift\", \"scale\"), shift = c(4000, 2000), scale = 1.1) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_placebo.sf3 <- shift_border(border = cut_off.sf, operation = c(\"shift\", \"scale\"), shift = c(6000, 3000), scale = 1.2) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_shape(polygon_full.sf) + tm_polygons() + tm_shape(cut_off.sf) + tm_lines() +    tm_shape(tm_placebo.sf1) + tm_lines(col = \"red\") +   tm_shape(tm_placebo.sf2) + tm_lines(col = \"red\") +   tm_shape(tm_placebo.sf3) + tm_lines(col = \"red\") tm_shift.sf <- shift_border(border = cut_off.sf, operation = c(\"shift\", \"rotate\", \"scale\"),                                shift = c(-10000, -1000), angle = 0, scale = .9) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! tm_shape(cut_off.sf) + tm_lines() + tm_shape(tm_shift.sf) + tm_lines(col = \"red\") polygon1 <- cutoff2polygon(data = points_samp.sf, cutoff = tm_placebo.sf1, orientation = c(\"west\", \"west\"), endpoints = c(.8, .2), # corners = 0,                            #     crs = 32643                            ) polygon2 <- cutoff2polygon(data = points_samp.sf, cutoff = tm_placebo.sf2, orientation = c(\"west\", \"west\"), endpoints = c(.8, .2), # corners = 0,                            #     crs = 32643                            ) polygon3 <- cutoff2polygon(data = points_samp.sf, cutoff = tm_placebo.sf3, orientation = c(\"west\", \"west\"), endpoints = c(.8, .2), # corners = 0,                            #     crs = 32643                            )  tm_shape(polygon_full.sf) + tm_polygons() +    tm_shape(polygon_treated.sf) + tm_polygons(col = \"grey\") +    tm_shape(cut_off.sf) + tm_lines(col = \"red\") +   tm_shape(polygon1) + tm_polygons(alpha = .3) +   tm_shape(polygon2) + tm_polygons(alpha = .3) +   tm_shape(polygon3) + tm_polygons(alpha = .3)"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"some-words-of-caution","dir":"Articles","previous_headings":"","what":"Some words of caution","title":"SpatialRDD: get started","text":"(obviously) pay attention RD border fine-grained enough resembles true cutoff. Something degree e.g. widely used GADM boundaries (just example, administrative boundaries usually never valid RD cutoffs due compound treatment problem) probably detailed enough. Furthermore suggested always work localised projection system metres units - opposed e.g. degrees (can check st_crs(data)$units). good choice UTM: find right grid , get corresponding EPSG number use st_transform() imported data.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"setup-and-propaedeutics","dir":"Articles","previous_headings":"","what":"Setup and Propaedeutics","title":"SpatialRDD: get started","text":"Throughout vignette use geographic boundaries Goa, India, Lehner (2019). data, included package, contains line called cut_off.sf describes spatial discontinuity polygon defines “treated” area polygon defines full study area (going useful defines bounding box) RD design need 1. form either line (single feature, .e. potential segments merged together) finely spaced set points border. Furthermore need polygon specifies treatment area, , course, dataset contains units observation, including x- y-coordinate unit observation. way easy convert data sf data.frame. come EPSG EPSG:32643, “localised” UTM coordinate reference system (CRS). generally prefereable exercises like Spatial RDD, precise also allow us work metres (“classic” longitude/latitude CRS, EPSG 4326, works degrees). study area small, reproject data CRS according UTM zone (simply use st_transform()). verify units CRS simply run st_crs(cut_off.sf)$units. spatial objects class sf sf package. means just data.frame special column contains geometry row. big advantage , matter prefer base R, dplyr, way handle wrangle data, sf object can treated just like standard data.frame. one single step transforms spatial objects back standard data.frame just dropping geometry column alternatively import geospatial data different format, say common shapefile (*.shp) - preferrable see , geopackage, fairly straightforward convert : case data saved .csv (stata file format, check foreign readstata13 package) just tell sf columns X- Y-coordinates saved, convert spatial object: thorough information suggest consult documentation vignettes sf package.","code":"library(SpatialRDD) library(dplyr) # more intuitive data wrangling library(stargazer) # easy way to make model output look more appealing (R-inline, html, or latex) library(sf) st_geometry(any.sf.object) <- NULL st_set_geometry(any.sf.object, NULL) mydata.sf <- st_read(\"path/to/file.shp\") mydata.sf <- st_as_sf(loaded_file, coords = c(\"longitude\", \"latitude\"), crs = projcrs)  # just the EPSG as an integer or a proj4string of the desired CRS"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"inspecting-the-study-area-simulating-data","dir":"Articles","previous_headings":"Setup and Propaedeutics","what":"Inspecting the Study Area & simulating Data","title":"SpatialRDD: get started","text":"see simple map, visualising “treated polygon” darker grey, tmap syntax produced . Let’s simulate random points within polygon describes full study area:","code":"data(cut_off.sf, polygon_full.sf, polygon_treated.sf) library(tmap) tm_shape(polygon_full.sf) + tm_polygons() +    tm_shape(polygon_treated.sf) + tm_polygons(col = \"grey\") +    tm_shape(cut_off.sf) + tm_lines(col = \"red\") set.seed(1088) # set a seed to make the results replicable points_samp.sf <- sf::st_sample(polygon_full.sf, 1000) points_samp.sf <- sf::st_sf(points_samp.sf) # make it an sf object bc st_sample only created the geometry list-column (sfc) points_samp.sf$id <- 1:nrow(points_samp.sf) # add a unique ID to each observation # visualise results together with the line that represents our RDD cut-off tm_shape(points_samp.sf) + tm_dots() + tm_shape(cut_off.sf) + tm_lines(col = \"red\")"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"assign-treatment","dir":"Articles","previous_headings":"Setup and Propaedeutics","what":"Assign Treatment","title":"SpatialRDD: get started","text":"Now use first function SpatialRDD package. assign_treated() essence just spatial intersection returns column vector contains 0 1, depending whether observation inside outside treatment area. Thus, just add new column points object. function requires name points object, name polygon defines treated area, id uniquely identifies observation points object:  next step add outcome interest going use dependent variable Spatial Regression Discontinuity Design. Let’s call variable education, measuring literacy rate ranges 0 1 (0%, meaning everyone illiterate 100%, meaning everyone population can read write). assume units, call villages, “treated” polygon average higher literacy rate received sort “treatment”. Let’s just assume aliens dropped (better) schools villages, outside villages, everything else constant identical across two territories.  histograms can see successful creating different group means. also confirmed simple univariate regression \\(y_i = \\alpha + \\beta\\ \\unicode{x1D7D9}(treated)_i + \\varepsilon_i\\): intercept tells us average non-treated areas 0.6 treated villages average 0.1 education (10 percentage points).","code":"points_samp.sf$treated <- assign_treated(points_samp.sf, polygon_treated.sf, id = \"id\") tm_shape(points_samp.sf) + tm_dots(\"treated\", palette = \"Set1\") + tm_shape(cut_off.sf) + tm_lines(col = \"red\") # first we define a variable for the number of \"treated\" and control which makes the code more readable in the future NTr <- length(points_samp.sf$id[points_samp.sf$treated == 1]) NCo <- length(points_samp.sf$id[points_samp.sf$treated == 0]) # the treated areas get a 10 percentage point higher literacy rate points_samp.sf$education[points_samp.sf$treated == 1] <- 0.7 points_samp.sf$education[points_samp.sf$treated == 0] <- 0.6 # and we add some noise, otherwise we would obtain regression coeffictions with no standard errors # we draw from a normal with mean 0 and a standard devation of 0.1 points_samp.sf$education[points_samp.sf$treated == 1] <- rnorm(NTr, mean = 0, sd = .1) +   points_samp.sf$education[points_samp.sf$treated == 1] points_samp.sf$education[points_samp.sf$treated == 0] <- rnorm(NCo, mean = 0, sd = .1) +   points_samp.sf$education[points_samp.sf$treated == 0]  # let's also add a placebo outcome that has no jump points_samp.sf$placebo <- rnorm(nrow(points_samp.sf), mean = 1, sd = .25)  # visualisation split up by groups library(ggplot2) ggplot(points_samp.sf, aes(x = education)) + geom_histogram(binwidth = .01) + facet_grid(treated ~ .) list(lm(education ~ treated, data = points_samp.sf),      lm(placebo   ~ treated, data = points_samp.sf)) %>% stargazer::stargazer(type = \"text\") #>  #> =========================================================== #>                                    Dependent variable:      #>                                ---------------------------- #>                                   education      placebo    #>                                      (1)           (2)      #> ----------------------------------------------------------- #> treated1                          0.100***        0.035*    #>                                    (0.008)       (0.020)    #>                                                             #> Constant                          0.600***       0.990***   #>                                    (0.004)       (0.009)    #>                                                             #> ----------------------------------------------------------- #> Observations                        1,000         1,000     #> R2                                  0.160         0.003     #> Adjusted R2                         0.160         0.002     #> Residual Std. Error (df = 998)      0.100         0.260     #> F Statistic (df = 1; 998)        186.000***       3.100*    #> =========================================================== #> Note:                           *p<0.1; **p<0.05; ***p<0.01"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"distance-to-cut-off","dir":"Articles","previous_headings":"Setup and Propaedeutics > Assign Treatment","what":"Distance to Cut-off","title":"SpatialRDD: get started","text":"next essential step start proper Spatial RDD analysis, determine far points away cut-. just make use function sf called st_distance() returns vector units (convert real numbers .numeric()): allows us now investigate villages within certain range, say 3 kilometres, around “discontinuity”:  run univariate regression also just within bandwith (specification already starting resemble RDD idea Dell 2010). know exact data generating process (“spatial gradient” rather uniform assignment), obvious us course leaves point estimate essentially unchanged:","code":"points_samp.sf$dist2cutoff <- as.numeric(sf::st_distance(points_samp.sf, cut_off.sf)) tm_shape(points_samp.sf[points_samp.sf$dist2cutoff < 3000, ]) + tm_dots(\"education\", palette = \"RdYlGn\", size = .1) +    tm_shape(cut_off.sf) + tm_lines() lm(education ~ treated, data = points_samp.sf[points_samp.sf$dist2cutoff < 3000, ]) %>% stargazer::stargazer(type = \"text\") #>  #> =============================================== #>                         Dependent variable:     #>                     --------------------------- #>                              education          #> ----------------------------------------------- #> treated1                     0.090***           #>                               (0.015)           #>                                                 #> Constant                     0.610***           #>                               (0.011)           #>                                                 #> ----------------------------------------------- #> Observations                    159             #> R2                             0.190            #> Adjusted R2                    0.180            #> Residual Std. Error      0.095 (df = 157)       #> F Statistic           36.000*** (df = 1; 157)   #> =============================================== #> Note:               *p<0.1; **p<0.05; ***p<0.01"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"carrying-out-spatial-rdd-estimation","dir":"Articles","previous_headings":"","what":"Carrying out Spatial RDD estimation","title":"SpatialRDD: get started","text":"Now go step step potential (parametric non-parametric) ways one obtain point estimates Spatial RDD’s (see e.g. Lehner2019 details).","code":""},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"naive-distance","dir":"Articles","previous_headings":"Carrying out Spatial RDD estimation","what":"Naive Distance","title":"SpatialRDD: get started","text":"“naive” estimation (KeeleTitiunik2015), meaning spatial dimension essentially disregarded, first define variable distrunning makes distances treated areas negative 2-dimensional cut-0.  point estimate “classic” non-parametric local linear regression, carried rdrobust package, looks like : according visualisation data driven bin-width selection:  RDD estimation R general currently three packages flying around: RDD, rddtools, rddapp (building RDD); whereby latter seems --date comprehensive one (draws previous work others ).rddapp estimates various specifications (robust inference though) gives several possibilities visualising classic RDDs. arbitrarily pick one parametric one non-parametric estimate, including confidence intervals, manually chosen binsizes:","code":"points_samp.sf$distrunning <- points_samp.sf$dist2cutoff # give the non-treated one's a negative score points_samp.sf$distrunning[points_samp.sf$treated == 0] <- -1 * points_samp.sf$distrunning[points_samp.sf$treated == 0] ggplot(data = points_samp.sf, aes(x = distrunning, y = education)) + geom_point() + geom_vline(xintercept = 0, col = \"red\") library(rdrobust) summary(rdrobust(points_samp.sf$education, points_samp.sf$distrunning, c = 0)) #> Call: rdrobust #>  #> Number of Obs.                 1000 #> BW type                       mserd #> Kernel                   Triangular #> VCE method                       NN #>  #> Number of Obs.                 785         215 #> Eff. Number of Obs.            127         100 #> Order est. (p)                   1           1 #> Order bias  (q)                  2           2 #> BW est. (h)               4248.546    4248.546 #> BW bias (b)               6601.220    6601.220 #> rho (h/b)                    0.644       0.644 #> Unique Obs.                    785         215 #>  #> ============================================================================= #>         Method     Coef. Std. Err.         z     P>|z|      [ 95% C.I. ]        #> ============================================================================= #>   Conventional     0.116     0.025     4.580     0.000     [0.066 , 0.166]      #>         Robust         -         -     4.089     0.000     [0.064 , 0.181]      #> ============================================================================= rdplot(points_samp.sf$education, points_samp.sf$distrunning, c = 0, ci = 95,         kernel = \"triangular\", y.label = \"education\", x.label = \"distance to border\") library(rddapp) summary(rd_est(education ~ distrunning, data = points_samp.sf, t.design = \"g\")) plot(rd_est(education ~ distrunning, data = points_samp.sf, t.design = \"g\"), fit_line = c(\"quadratic\", \"optimal\"), bin_n = 50)"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"parametric-specifications","dir":"Articles","previous_headings":"Carrying out Spatial RDD estimation","what":"Parametric Specifications","title":"SpatialRDD: get started","text":"method, popularised Dell2010 JMP Peruvian Mining Mita, examines observations within certain distance around border using (semi-)parametric approach. point view additional “spatial technicalities” needed, essentially boils introduction border segments. used apply “within estimator” allow different intercepts segment categories order , inter alia, alleviate omitted variable problem. alternative fixed-effects approach might well throw set dummies segments regression. regression coefficient interest gives weighted average segments. top might also interested coefficient segment infer something potential heterogeneity alongside regression discontinuity. (computationally bit demanding) function border_segment() needs points layer cut-input (preferrably line, also input form boundarypoint works). last parameter function lets us determine many segments want. assign_treated() function, output vector factors.  worth noting researcher pay attention fixed effects assigned. , e.g. due odd bendings cut-, case segment one side actually gets assigned point. situations undesireable estimation. thus paramount always plot fixed-effect categories map! border_segment() already gives researcher feeling meaningful choice number segments . example segment every 13 kilometres, seems unreasonable. see however, FE categories contain verly little observations desireable several reasons. following example thus choose less borderpoints, leading observations side border every segment thus meaningful point estimates:  Simple OLS estimates, using segments just obtained categories fixed effects, show differences: confidence intervals point estimates overlapping, yet, one can see fixed effects choice can substantial impact. obtain point estimate (unsurprisingly, data generating process uniform across space) similar one obtained simple OLS regression beginning. compared “classic RD” point estimate obtained non-parametric local linear regression rdrobust package, point estimate fixed effects regression bit conservative. eyeballing can determine average effect lies somewhere around 0.1, meaning literacy rate 10 percentage points higher treated areas. Exactly way designed simulated data. “full” polynomial specification Dell2010 required also control position space via flexible polynomial function longitude latitude.","code":"points_samp.sf$segment10 <- border_segment(points_samp.sf, cut_off.sf, 10) #> Starting to create 10 border segments with an approximate length of 13 kilometres each. points_samp.sf$segment15 <- border_segment(points_samp.sf, cut_off.sf, 15) #> Starting to create 15 border segments with an approximate length of 9 kilometres each. tm_shape(points_samp.sf) + tm_dots(\"segment10\", size = 0.1) + tm_shape(cut_off.sf) + tm_lines() tm_shape(points_samp.sf) + tm_dots(\"segment15\", size = 0.1) + tm_shape(cut_off.sf) + tm_lines() points_samp.sf$segment5 <- border_segment(points_samp.sf, cut_off.sf, 5) #> Starting to create 5 border segments with an approximate length of 26 kilometres each. tm_shape(points_samp.sf) + tm_dots(\"segment5\", size = 0.1) + tm_shape(cut_off.sf) + tm_lines() library(lfe) #> Loading required package: Matrix list(lfe::felm(education ~ treated | factor(segment15) | 0 | 0, data = points_samp.sf[points_samp.sf$dist2cutoff < 3000, ]), lfe::felm(education ~ treated | factor(segment5) | 0 | 0, data = points_samp.sf[points_samp.sf$dist2cutoff < 3000, ]) ) %>% stargazer::stargazer(type = \"text\") #>  #> ===================================================== #>                            Dependent variable:        #>                     --------------------------------- #>                                 education             #>                           (1)              (2)        #> ----------------------------------------------------- #> treated1                0.094***         0.089***     #>                         (0.016)          (0.015)      #>                                                       #> ----------------------------------------------------- #> Observations              159              159        #> R2                       0.280            0.250       #> Adjusted R2              0.200            0.220       #> Residual Std. Error 0.094 (df = 143) 0.092 (df = 153) #> ===================================================== #> Note:                     *p<0.1; **p<0.05; ***p<0.01"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"grd","dir":"Articles","previous_headings":"Carrying out Spatial RDD estimation","what":"GRD","title":"SpatialRDD: get started","text":"Finally move towards fully fledged Geographic Regression Discontinuity (GRD) design (KeeleTitiunik2015). function spatialrd() incorporates RD estimation two running variables, also allows carry estimation boundarypoint (“GRDDseries”) just one line code. allows us visualise treatment effect multiple points cut-thus infer something potential heterogeneity effect. , importantly, assess robustness GRD . future version SpatialRDD also incorporate “Optimized RDD” approach ImbensWager2019. First cut border equally spaced segments. segments, rather boundarypoints, later obtain point estimate. discretise_border() function just requires sf object represent cut-(polyline preferred also points possible) number desired boundarypoints:  plotting just results table, preferrable choose just data.frame output (spatial.object = F). average treatment effect given taking mean point estimates. Running mean(results$Estimate) gives 0.12, exactly designed DGP. plotting GRDDseries visualisation space point estimate need spatial object. incorporated plotspatialrd() function.  just GRDDseries without map.","code":"borderpoints.sf <- discretise_border(cutoff = cut_off.sf, n = 50) #> Starting to create 50 borderpoints from the given set of borderpoints. Approximately every 3 kilometres we can run an estimation then. borderpoints.sf$id <- 1:nrow(borderpoints.sf) # exclude some of the borderpoints with little n so that the vignette can compile without warning: #borderpoints.sf <- borderpoints.sf %>% slice(c(5,10,20,30,40)) tm_shape(points_samp.sf[points_samp.sf$dist2cutoff < 3000, ]) + tm_dots(\"education\", palette = \"RdYlGn\", size = .1) +   tm_shape(cut_off.sf) + tm_lines() +   tm_shape(borderpoints.sf) + tm_symbols(shape = 4, size = .3) results <- spatialrd(y = \"education\", data = points_samp.sf, cutoff.points = borderpoints.sf, treated = \"treated\", minobs = 10, spatial.object = F) knitr::kable(results) results <- spatialrd(y = \"education\", data = points_samp.sf, cutoff.points = borderpoints.sf, treated = \"treated\", minobs = 10) plotspatialrd(results, map = T) plotspatialrd(results, map = F)"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"robustness","dir":"Articles","previous_headings":"","what":"Robustness","title":"SpatialRDD: get started","text":"Spatial Regression Discontinuity exercises, researcher usually also show results robust towards different specifications parameters. Also respect SpatialRDD package offers lot capabilities time saving make replicability easy. toolbox shifting moving around borders afterwards assigning (placebo) treatment status fact potent, use many research design settings outside geographic RDs. vignette just see basic intuiton. details options check separate vignette shifting_borders.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"placebo-borders","dir":"Articles","previous_headings":"Robustness","what":"Placebo Borders","title":"SpatialRDD: get started","text":"going apply standard tool got know linear algebra 1 classes: affine transformation type \\(f(x) = x\\mathbf{}+b\\), matrix \\(\\mathbf{}\\) projection matrix shift, (re-)scale, rotate border. simplicity now apply shift 3000 metres x y coordinates border.  border shift now re-assign new treatment status order carry regressions. matter create new polygons scratch cutoff2polygons() function. logic function intuitive first, vignette border shifting clarify . case go around corners counterfactual polygon ends cutoff go towards west. Just make sure endpoints chosen way observations “placebo treated” group also actually inside resulting polygon.  Finally use assign_treated() function beginning vignette :  plotting points , can visually infer right villages got assign “treated” dummy. can compute number villages change status. helps us decide whether bordershift big enough (e.g. handful observations switched, expect little impact point estimates thus dub robustness exercise meaningful). case 60 villages changed. Given initial number treated observations, seems change big enough magnitude thus meaningful robustness exercise.","code":"placebocut_off.1 <- shift_border(cut_off.sf, operation = \"shift\", shift = c(3000, 3000)) #> Pay attention to CRS! If you work in lon/lat then degrees have to be provided. Local UTM CRS is preferable! placeboborderpoints.1 <- discretise_border(cutoff = placebocut_off.1, n = 50) #> Starting to create 50 borderpoints from the given set of borderpoints. Approximately every 3 kilometres we can run an estimation then. tm_shape(points_samp.sf) + tm_dots(\"treated\", palette = \"Set1\")  + tm_shape(placeboborderpoints.1) + tm_symbols(shape = 4, size = .3) + tm_shape(placebocut_off.1) + tm_lines() placebo.poly.1 <- cutoff2polygon(data = points_samp.sf, cutoff = placebocut_off.1, orientation = c(\"west\", \"west\"), endpoints = c(.8, .2))  tm_shape(placebo.poly.1) + tm_polygons(alpha = .3) points_samp.sf$treated1 <- assign_treated(data = points_samp.sf, polygon = placebo.poly.1, id = \"id\") sum(points_samp.sf$treated == 0 & points_samp.sf$treated1 == 1) # number of villages that switched treatment status #> [1] 60 tm_shape(points_samp.sf) + tm_dots(\"treated1\", palette = \"Set1\")  + tm_shape(placeboborderpoints.1) + tm_symbols(shape = 4, size = .3) + tm_shape(placebocut_off.1) + tm_lines()"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"robustness-grd","dir":"Articles","previous_headings":"Robustness > Placebo Borders","what":"Robustness GRD","title":"SpatialRDD: get started","text":"Finally exact exercise run nonparametric specification many boundary points approximate countinous treatment effect. series fluctuating around 0 single significant estimate thus save conclude methodology works.","code":"results1 <- spatialrd(y = \"education\", data = points_samp.sf, cutoff.points = placeboborderpoints.1, treated = \"treated1\", minobs = 10) plotspatialrd(results1, map = T)"},{"path":"https://axlehner.github.io/SpatialRDD/articles/spatialrdd_vignette.html","id":"robustness-polynomial-specification","dir":"Articles","previous_headings":"Robustness > Placebo Borders","what":"Robustness Polynomial Specification","title":"SpatialRDD: get started","text":"Finally also run placebo exercise parametric specification. Unfortunately OLS fixed effects sensitive comes detecting border shift. coefficient still borderline significant. case moved border 1 2 kilometres farther make insignificant.","code":"points_samp.sf$segment.1.5 <- border_segment(points_samp.sf, placebocut_off.1, 5) # assigning new segments based on now cutoff #> Starting to create 5 border segments with an approximate length of 26 kilometres each. points_samp.sf$dist2cutoff1 <- as.numeric(sf::st_distance(points_samp.sf, placebocut_off.1)) # recompute distance to new placebo cutoff  list(   lm(education ~ treated1, data = points_samp.sf[points_samp.sf$dist2cutoff1 < 3000, ]),   lfe::felm(education ~ treated1 | factor(segment.1.5) | 0 | 0, data = points_samp.sf[points_samp.sf$dist2cutoff1 < 3000, ]) ) %>% stargazer::stargazer(type = \"text\") #>  #> ======================================================== #>                             Dependent variable:          #>                     ------------------------------------ #>                                  education               #>                             OLS               felm       #>                             (1)               (2)        #> -------------------------------------------------------- #> treated11                  0.021             0.018       #>                           (0.015)           (0.015)      #>                                                          #> Constant                 0.620***                        #>                           (0.010)                        #>                                                          #> -------------------------------------------------------- #> Observations                177               177        #> R2                         0.011             0.032       #> Adjusted R2                0.005             0.004       #> Residual Std. Error  0.100 (df = 175)   0.100 (df = 171) #> F Statistic         1.900 (df = 1; 175)                  #> ======================================================== #> Note:                        *p<0.1; **p<0.05; ***p<0.01"},{"path":"https://axlehner.github.io/SpatialRDD/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alexander Lehner. Author, maintainer.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lehner (2022). SpatialRDD: Spatial Regression Discontinuity Designs. R package version 0.1.0, https://axlehner.github.io/SpatialRDD/.","code":"@Manual{,   title = {SpatialRDD: Spatial Regression Discontinuity Designs},   author = {Alexander Lehner},   year = {2022},   note = {R package version 0.1.0},   url = {https://axlehner.github.io/SpatialRDD/}, }"},{"path":"https://axlehner.github.io/SpatialRDD/index.html","id":"spatialrdd","dir":"","previous_headings":"","what":"Spatial Regression Discontinuity Designs","title":"Spatial Regression Discontinuity Designs","text":"repository hosts code underlying R package SpatialRDD. workhorse functions nutshell : assign_treated() border_segment() discretise_border() spatialrd() plotspatialrd() printspatialrd() shift_border() cutoff2polygon() package can estimate heterogenous treatment effects alongside RD cutoff. Moreover provides powerful spatial functions carry placebo exercises (move borders reassign (placebo) treatment status). functionalities also useful different empirical identification strategies rely flexibly changing geographic boundaries. full guidance check different vignettes vignettes folder github vignette(spatialrdd_vignette) vignette(shifting_borders) R console. functions presented latter potentially useful research designs rely (randomly) shifting (many) borders.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Spatial Regression Discontinuity Designs","text":"need run spatial RD SpatialRDD: RD boundary single line (simplest way cut hand e.g. ArcGIS QGIS just splitting line polygon example - also make sure merge features together case multiple left, important prevent annoying troubles later ) data frame containing columns x- y-coordinates. Read read.csv() readstata13::read.dta13(). Make sf object st_as_sf(data, coords = c(\"x\", \"y\"), crs = 4326) longitude/latitude coordinates (reflected 4326 EPSG). case use st_transform() objects local UTM projection (necessary recommended several reasons). Note: case data comes shapefile/geopackage/etc. directly, just read st_read(\"path//file.shp\"). polygons advised work centroids straightaway (extract st_centroid()). need zonal statistics (elevation/ruggednes etc.) e.g. checking identifying assumptions, converting centroids. Ideally also polygon covers treated areas (created within package cutoff2polygon though) verify “geographic validity” objects e.g. mapview::mapview().","code":"install.packages(\"devtools\") devtools::install_github(\"axlehner/SpatialRDD\") # add build_vignettes = TRUE if you want to have access to them via R, otherwise just look at the .Rmd on github in \\vignettes"},{"path":"https://axlehner.github.io/SpatialRDD/index.html","id":"quick-guide","dir":"","previous_headings":"","what":"Quick Guide","title":"Spatial Regression Discontinuity Designs","text":"Adding border segment transparent fixed effect category creation (non-parametric specification just OLS lm() lfe::felm()):  Create points alongside border run GRD explore heterogeneity:","code":"points_samp.sf$segment5 <- border_segment(points_samp.sf, cut_off.sf, 5) #> Starting to create 5 border segments with an approximate length of 26 kilometres each. tm_shape(points_samp.sf) + tm_dots(\"segment5\", size = 0.1) + tm_shape(cut_off.sf) + tm_lines() borderpoints.sf <- discretise_border(cutoff = cut_off.sf, n = 50) #> Starting to create 50 borderpoints from the given set of borderpoints. Approximately every 3 kilometres we can run an estimation then. results <- spatialrd(y = \"education\", data = points_samp.sf, cutoff.points = borderpoints.sf, treated = \"treated\", minobs = 10) plotspatialrd(results, map = T)"},{"path":[]},{"path":"https://axlehner.github.io/SpatialRDD/reference/assign_treated.html","id":null,"dir":"Reference","previous_headings":"","what":"Let the package know which observations were treated — assign_treated","title":"Let the package know which observations were treated — assign_treated","text":"Creates vector 0's 1's determine side cut-observation . useful polygon fully describes \"treated area\". polygon (preliminary patchy) way implemented package via points2line cutoff2polygon lets go points line \"treated polygon\" crude way.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/assign_treated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Let the package know which observations were treated — assign_treated","text":"","code":"assign_treated(data, polygon, id = NA)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/assign_treated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Let the package know which observations were treated — assign_treated","text":"data sf data frame containing point data (polygons, convert first sf::st_centroid()) polygon sf object polygon geometry fully describes area(s) contain treated points id string represents name column data represents unique identifier observation","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/assign_treated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Let the package know which observations were treated — assign_treated","text":"vector type factor 0's 1's. Convert .numeric() want real numbers/integers.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/assign_treated.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Let the package know which observations were treated — assign_treated","text":"essentially wrapper sf::st_intersection.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/assign_treated.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Let the package know which observations were treated — assign_treated","text":"","code":"if (FALSE) points.sf$treated <- assign_treated(points.sf, polygon_treated.sf, id = \"id\")"},{"path":"https://axlehner.github.io/SpatialRDD/reference/border_segment.html","id":null,"dir":"Reference","previous_headings":"","what":"Border Segment Creation for FE-estimation — border_segment","title":"Border Segment Creation for FE-estimation — border_segment","text":"Creates n segments line (RD cut-) assigns closest border segment observation sf data frame. Computationally tasks quite demanding sample size big thus might take seconds complete.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/border_segment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Border Segment Creation for FE-estimation — border_segment","text":"","code":"border_segment(data, cutoff, n = 10)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/border_segment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Border Segment Creation for FE-estimation — border_segment","text":"data sf data frame containing point data cutoff RDD border form line (preferred) borderpoints n number segments produced","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/border_segment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Border Segment Creation for FE-estimation — border_segment","text":"vector factors, category representing one segment","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/border_segment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Border Segment Creation for FE-estimation — border_segment","text":"","code":"if (FALSE) points.sf$segment10 <- border_segment(points.sf, cut_off.sf, 10)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/create_placebos.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiple placebocheks unified in just one list or coefplot — create_placebos","title":"Multiple placebocheks unified in just one list or coefplot — create_placebos","text":"Unifies shift_border, cutoff2polygon, assign_treated one function carry myriad placebo checks . output either data.frame (without geometry respective placeboline) coefplot. Requires operations data.frame contains desired operations (columns shift.x, shift.y, scale, angle, orientation.1, orientation.2, endpoint.1, endpoint.2), need certain operation just use default values (e.g. 0 angle 1 scale), column .","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/create_placebos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiple placebocheks unified in just one list or coefplot — create_placebos","text":"","code":"create_placebos(   data,   cutoff,   formula,   operations,   bw_dist,   coefplot = F,   geometry = F )"},{"path":"https://axlehner.github.io/SpatialRDD/reference/create_placebos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiple placebocheks unified in just one list or coefplot — create_placebos","text":"data sf data.frame contains units observation cutoff initial RD cutoff sj object formula provide formula want use OLS, omit treatetment dummy (want univariate regression just \"treated\", provide y ~ 1 formula) operations container information change border placeboregression bw_dist distance bandwith (CRS units, thus ideally metres) coefplot provide coefplot instead data.frame geometry set TRUE want plot lines used placebo borders","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/create_placebos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiple placebocheks unified in just one list or coefplot — create_placebos","text":"either coefplot data.frame containing results placeboregressions","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/create_placebos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiple placebocheks unified in just one list or coefplot — create_placebos","text":"","code":"if (FALSE) create_placebos(data = points_samp.sf, cutoff = cut_off.sf, formula = education ~ 1, operations = operations)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/cut_off.sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Dataset with boundaries and polygons for the SpatialRDD vignette. — cut_off.sf","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — cut_off.sf","text":"sf multilinestring representing spatial RD cut-","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/cut_off.sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — cut_off.sf","text":"","code":"data(cut_off.sf)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/cut_off.sf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — cut_off.sf","text":"spatial data.frame class sf","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/cut_off.sf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — cut_off.sf","text":"Lehner, . (2019) 450 Years Portuguese Colonialism India: Missionaries, Education, Roots Gender Inequality","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/cutoff2polygon.html","id":null,"dir":"Reference","previous_headings":"","what":"Create (treated) polygon from line — cutoff2polygon","title":"Create (treated) polygon from line — cutoff2polygon","text":"Creates approximation \"treated/untreated polygon\" assign status observation border shifted. function extends ends provided cutoff edge (imaginary) bounding box provided data (ensures observations included). Key provide 2-tuple indicates side bounding box end go (1st element one lower x-coordinate, .e. leftern ). Always check output manually plotting polygon (e.g. tm_shape(.polygon) + tm_polygons()). output polygon looks odd, first check just switch elements orientation vector around! See vignette(shifting_borders) details illustrative examples.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/cutoff2polygon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create (treated) polygon from line — cutoff2polygon","text":"","code":"cutoff2polygon(   data,   cutoff,   orientation = NA,   endpoints = c(0, 0),   messages = T )"},{"path":"https://axlehner.github.io/SpatialRDD/reference/cutoff2polygon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create (treated) polygon from line — cutoff2polygon","text":"data study dataset determine bounding box (observations covered new polygons) sf format cutoff sf object (placebo) cut-orientation side bounding box extensions cutoff go ? First element refers endpoint border smaller x-coordinate (\"westernmost\") (takes two \"north\", \"east\", \"south\", \"west\" vector, e.g. c(\"west\", \"north\")) endpoints position edge polygon end? (vector two numbers 0 1, 0.5 e.g. means right middle respective edge) messages set FALSE want ","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/cutoff2polygon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create (treated) polygon from line — cutoff2polygon","text":"polygon sf object","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/cutoff2polygon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create (treated) polygon from line — cutoff2polygon","text":"","code":"if (FALSE) cutoff2polygon(data = points_samp.sf, cutoff = placebocut_off.1, orientation = c(\"west\", \"west\"), endpoints = c(.8, .2)) if (FALSE) cutoff2polygon(data = points_samp.sf, cutoff = placebocut_off.1, orientation = c(\"north\", \"east\"), endpoints = c(.5, .5)) if (FALSE) cutoff2polygon(data = points_samp.sf, cutoff = placebocut_off.1, orientation = c(\"north\", \"south\"), endpoints = c(.5, .5))"},{"path":"https://axlehner.github.io/SpatialRDD/reference/discretise_border.html","id":null,"dir":"Reference","previous_headings":"","what":"Split the RD cut-off into borderpoints — discretise_border","title":"Split the RD cut-off into borderpoints — discretise_border","text":"Takes border form polyline (borderpoints) converts point data. points later used run separate non-parametric RD estimations eventually allows visualise potential heterogeneous treatment effects alongside cut-.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/discretise_border.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split the RD cut-off into borderpoints — discretise_border","text":"","code":"discretise_border(   cutoff,   n = 10,   random = F,   range = F,   ymax = NA,   ymin = NA,   xmax = NA,   xmin = NA )"},{"path":"https://axlehner.github.io/SpatialRDD/reference/discretise_border.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split the RD cut-off into borderpoints — discretise_border","text":"cutoff sf object RD cut-form line (preferred, also boundarypoints possible) n number borderpoints created random whether randomly chosen (desireable cases) range default = F, specific range (N-S E-W) points drawn (useful order exclude sparse borderpoints little/oberservations around non-parametric RD estimation fail) ymax range = T: y coordinates ymin range = T: y coordinates xmax range = T: x coordinates xmin range = T: x coordinates","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/discretise_border.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split the RD cut-off into borderpoints — discretise_border","text":"sf object selected (evenly spaced) borderpoints","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/discretise_border.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split the RD cut-off into borderpoints — discretise_border","text":"","code":"if (FALSE) borderpoints.sf <- discretise_border(cutoff = cut_off.sf, n = 50)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr pkg documentation details.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://axlehner.github.io/SpatialRDD/reference/plotspatialrd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot SpatialRD output — plotspatialrd","title":"Plot SpatialRD output — plotspatialrd","text":"Produces plot GRDDseries optionally map visualises every point estimate space.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/plotspatialrd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot SpatialRD output — plotspatialrd","text":"","code":"plotspatialrd(SpatialRDoutput, map = F)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/plotspatialrd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot SpatialRD output — plotspatialrd","text":"SpatialRDoutput spatial obkect produced estimation spatialrd map T/F depending whether mapplot desired (make sure set spatial.objcet = T spatialrd function)","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/plotspatialrd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot SpatialRD output — plotspatialrd","text":"plots produced ggplot2","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/plotspatialrd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot SpatialRD output — plotspatialrd","text":"","code":"if (FALSE) plotspatialrd(results.spatialrd)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/points2line.html","id":null,"dir":"Reference","previous_headings":"","what":"Title\nthis is just a test function, export was removed for now — points2line","title":"Title\nthis is just a test function, export was removed for now — points2line","text":"Title just test function, export removed now","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/points2line.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title\nthis is just a test function, export was removed for now — points2line","text":"","code":"points2line(borderpoints, crs)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/points2line.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title\nthis is just a test function, export was removed for now — points2line","text":"borderpoints test crs test","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/points2line.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title\nthis is just a test function, export was removed for now — points2line","text":"line sf object","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/points2line.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title\nthis is just a test function, export was removed for now — points2line","text":"","code":"if (FALSE) test"},{"path":"https://axlehner.github.io/SpatialRDD/reference/polygon_full.sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_full.sf","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_full.sf","text":"sf multipolygon","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/polygon_full.sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_full.sf","text":"","code":"data(polygon_full.sf)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/polygon_full.sf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_full.sf","text":"spatial data.frame class sf","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/polygon_full.sf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_full.sf","text":"Lehner, . (2019) 450 Years Portuguese Colonialism India: Missionaries, Education, Roots Gender Inequality","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/polygon_treated.sf.html","id":null,"dir":"Reference","previous_headings":"","what":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_treated.sf","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_treated.sf","text":"sf multipolygon","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/polygon_treated.sf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_treated.sf","text":"","code":"data(polygon_treated.sf)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/polygon_treated.sf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_treated.sf","text":"spatial data.frame class sf","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/polygon_treated.sf.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Dataset with boundaries and polygons for the SpatialRDD vignette. — polygon_treated.sf","text":"Lehner, . (2019) 450 Years Portuguese Colonialism India: Missionaries, Education, Roots Gender Inequality","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/printspatialrd.html","id":null,"dir":"Reference","previous_headings":"","what":"Print spatialrd output — printspatialrd","title":"Print spatialrd output — printspatialrd","text":"Preliminary function using kable kableextra. also just use package choice print columns output spatialrd.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/printspatialrd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print spatialrd output — printspatialrd","text":"","code":"printspatialrd(SpatialRDoutput, format = \"latex\")"},{"path":"https://axlehner.github.io/SpatialRDD/reference/printspatialrd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print spatialrd output — printspatialrd","text":"SpatialRDoutput output file spatialrd function format now latex","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/printspatialrd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print spatialrd output — printspatialrd","text":"formatted table results spatialrd function","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/printspatialrd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print spatialrd output — printspatialrd","text":"","code":"if (FALSE) printspatialrd(results.spatialrd)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/shift_border.html","id":null,"dir":"Reference","previous_headings":"","what":"Shift, shrink/grow, and rotate borders around — shift_border","title":"Shift, shrink/grow, and rotate borders around — shift_border","text":"functions takes border can either shift, shrink, rotate . can done together well. usually takes bit trial error, make sure plot result time. detailed walk check according vignette: vignette(shifting_borders).","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/shift_border.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shift, shrink/grow, and rotate borders around — shift_border","text":"","code":"shift_border(   border,   operation = c(\"shift\", \"scale\", \"rotate\"),   shift = c(0, 0),   scale = 1,   angle = 0,   messages = T )"},{"path":"https://axlehner.github.io/SpatialRDD/reference/shift_border.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shift, shrink/grow, and rotate borders around — shift_border","text":"border sf object line geometry operation \"shift\", \"rotate\", \"scale\" - combination shift operation = \"shift\", shift distance CRS units (UTM metres) x y coordinates c(dist_x, dist_y) scale operation = \"scale\", provide shrinkage/growth factor: e.g. .9 shrink 10perc. 1.1 increase 10perc. angle operation = \"rotate\", provide angle degrees messages set FALSE want ","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/shift_border.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shift, shrink/grow, and rotate borders around — shift_border","text":"new border form sf object","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/shift_border.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Shift, shrink/grow, and rotate borders around — shift_border","text":"","code":"if (FALSE) placebo_border(border = cut_off.sf, operation = c(\"shift\", \"scale\"), shift = c(-5000, -3000), scale = .85) if (FALSE) placebo_border(border = cut_off.sf, operation = \"rotate\", angle = 10)"},{"path":"https://axlehner.github.io/SpatialRDD/reference/spatialrd.html","id":null,"dir":"Reference","previous_headings":"","what":"non-parametric Spatial RD / GRD — spatialrd","title":"non-parametric Spatial RD / GRD — spatialrd","text":"function loops boundary points locally estimates non-parametric RD (local linear regression usual) using rdrobust function rdrobust package Calonico, Cattaneo, Titiunik (2014). takes discretized cutoff point file (RDcutoff linestring chopped parts discretise_border function) sf object (essentially just conventional data.frame geometry() column) containing observations (treated untreated). treated dummy variable assigned (potentially assign_treated) part sf object column.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/spatialrd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"non-parametric Spatial RD / GRD — spatialrd","text":"","code":"spatialrd(   y,   data,   cutoff.points,   treated,   minobs = 50,   bwfix_m = NA,   sample = FALSE,   samplesize = NA,   sparse.exclusion = FALSE,   print.msg = FALSE,   store.CIs = FALSE,   spatial.object = TRUE,   RATestvec = NA,   ... )"},{"path":"https://axlehner.github.io/SpatialRDD/reference/spatialrd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"non-parametric Spatial RD / GRD — spatialrd","text":"y name dependent variable points frame form string data sf data.frame points describe observations cutoff.points sf object borderpoints (provided user obtained discretise_border) treated column contains treated dummy (string) minobs minimum amount observations estimation point estimate included (default 50) bwfix_m fixed bandwidth meters (case want impose one ) sample draw random sample points T/F samplesize random, many points sparse.exclusion case want try exclude sparse border points estimation (reduce warnings) print.msg set TRUE want receive printed info store.CIs set TRUE confidence intervals stored spatial.object return spatial object (needed want plot point estimates map)? RATestvec vector strings basline covariates data object case RATest Canay, Kamat (2018) desired ... addition can use options rdrobust","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/spatialrd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"non-parametric Spatial RD / GRD — spatialrd","text":"data.frame spatial data.frame (sf object) case spatial.object = T (default)","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/spatialrd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"non-parametric Spatial RD / GRD — spatialrd","text":"function nests rdrobust. options (aside running variable x cutoff c) available well (e.g. bw selection, cluster level, kernel, weights). Check documentation rdrobust package details. (bandwidth selection default rdrobust bwselect = 'mserd') visualise output table, use printspatialrd plotspatialrd.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/spatialrd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"non-parametric Spatial RD / GRD — spatialrd","text":"Calonico, Cattaneo Titiunik (2014): Robust Nonparametric Confidence Intervals Regression-Discontinuity Designs, Econometrica 82(6): 2295-2326.","code":""},{"path":"https://axlehner.github.io/SpatialRDD/reference/spatialrd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"non-parametric Spatial RD / GRD — spatialrd","text":"","code":"if (FALSE) results <- spatialrd(y = \"education\", data = points_samp.sf, cutoff.points = borderpoints.sf, treated = \"treated\", minobs = 10, spatial.object = F)"}]
